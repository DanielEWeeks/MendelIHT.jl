<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · MendelIHT</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MendelIHT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>Getting Started</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Step-Workflow-1">3 Step Workflow</a></li><li><a class="toctext" href="#Core-Functions-1">Core Functions</a></li><li><a class="toctext" href="#Supported-GLM-models-and-Link-functions-1">Supported GLM models and Link functions</a></li><li><a class="toctext" href="#Specifying-Groups-and-Weights-1">Specifying Groups and Weights</a></li><li><a class="toctext" href="#Simulation-Utilities-1">Simulation Utilities</a></li><li><a class="toctext" href="#Other-Useful-Functions-1">Other Useful Functions</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Getting Started</a></li></ul><a class="edit-page" href="https://github.com/OpenMendel/MendelIHT.jl/blob/master/docs/src/man/getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>In this section, we outline the basic procedure to analyze your GWAS data with MendelIHT. </p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>MendelIHT.jl</code> have been tested on Julia 1.0 and 1.2 for Mac, Linus, and windows. A few features are disabled for windows users, and users will be warned when trying to use them.</p><p>Press <code>]</code> to enter package manager mode and type the following (after <code>pkg&gt;</code>):</p><pre><code class="language-none">(v1.0) pkg&gt; add https://github.com/OpenMendel/SnpArrays.jl
(v1.0) pkg&gt; add https://github.com/OpenMendel/MendelSearch.jl
(v1.0) pkg&gt; add https://github.com/OpenMendel/MendelBase.jl
(v1.0) pkg&gt; add https://github.com/biona001/MendelIHT.jl</code></pre><p>The order of installation is important!</p><h2><a class="nav-anchor" id="Step-Workflow-1" href="#Step-Workflow-1">3 Step Workflow</a></h2><p>Most analysis consists of 3 simple steps:</p><ol><li>Import data.</li><li>Run cross validation: either <code>cv_iht</code> or <code>cv_iht_distribute_folds</code> to determine best model size.</li><li>Run <code>L0_reg</code> to obtain final model.</li></ol><p>We believe the best way to learn is through examples. Head over to the example section on the left to see these steps in action. Nevertheless, below contains function signatures and use cautions that any users should be aware. </p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>(1) <code>MendelIHT</code> assumes there are <strong>NO missing genotypes</strong>, and (2) the trios (<code>.bim</code>, <code>.bed</code>, <code>.fam</code>) must all be present in the same directory. </p></div></div><h2><a class="nav-anchor" id="Core-Functions-1" href="#Core-Functions-1">Core Functions</a></h2><p>A standard analysis runs only 2 functions, other than importing data. For testing small problems (small number of folds), we recommend using <code>cv_iht</code>. This function cycles through the testing sets sequentially and fits different sparsity models in parallel. For larger problems where <code>L0_reg</code> takes a long time to run, one can instead run <code>cv_iht_distribute_fold</code>. This function fits different sparsity models sequentially but initializes all training/testing model in parallel, which consumes more memory (see below). The later strategy allows one to distribute different sparsity parameters to different computers, achieving greater parallel power. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.cv_iht" href="#MendelIHT.cv_iht"><code>MendelIHT.cv_iht</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cv_iht(d, l, x, z, y, J, path, q)</code></pre><p>For each model specified in <code>path</code>, performs <code>q</code>-fold cross validation and  returns the (averaged) deviance residuals.  The purpose of this function is to find the best sparsity level <code>k</code>, judiciously obtained from selecting the model with the minimum out-of-sample error. Automatically finds the  correct version of <code>L0_reg</code> to use depending on the type of <code>x</code>. By default, each CPU runs  a different model for a given fold. To use this function, start julia using 4 processors  (or more) by <code>using Distributed; addprocs(4)</code>.</p><p><strong>Warning</strong></p><p>Do not remove files with random file names when you run this function. There are  memory mapped files that will be deleted automatically once they are no longer needed.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: A distribution (e.g. Normal, Bernoulli)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li><li><code>x</code>: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra</li><li><code>z</code>: Matrix of non-genetic covariates. The first column usually denotes the intercept. </li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups (set as 1 if no group infomation available)</li><li><code>path</code>: Vector storing different model sizes</li><li><code>q</code>: Number of cross validation folds. For large data do not set this to be greater than 5</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>est_r</code> Symbol for whether to estimate nuisance parameters. Only supported distribution is negative binomial and choices include :Newton or :MM.</li><li><code>group</code> vector storing group membership</li><li><code>weight</code> vector storing vector of weights containing prior knowledge on each SNP</li><li><code>folds</code>: Vector that separates the sample into q disjoint subsets</li><li><code>destin</code>: Directory where intermediate files will be generated. Directory name must end with <code>/</code>.</li><li><code>init</code>: Boolean indicating whether we should initialize IHT algorithm at a good starting guess</li><li><code>use_maf</code>: Boolean indicating we should scale the projection step by a weight vector </li><li><code>debias</code>: Boolean indicating whether we should debias at each IHT step</li><li><code>verbose</code>: Whether we want IHT to print meaningful intermediate steps</li><li><code>parallel</code>: Whether we want to run cv_iht using multiple CPUs (highly recommended)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/cross_validation.jl#L2-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.cv_iht_distribute_fold" href="#MendelIHT.cv_iht_distribute_fold"><code>MendelIHT.cv_iht_distribute_fold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Performs q-fold cross validation for Iterative hard thresholding to  determine the best model size <code>k</code>. The function is the same as <code>cv_iht</code>  except here each <code>fold</code> is distributed to a different CPU as opposed  to each <code>path</code> to a different CPU. </p><p>This function has the edge over <code>cv_iht</code> because one can fit different  sparsity levels on different computers. But this is assuming you have  enough RAM and disk space to store all training data simultaneously.</p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/cross_validation.jl#L82-L91">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Do not</strong> delete intermediate files with random file names created by <code>cv_iht</code> and <code>cv_iht_distribute_fold</code> (windows users will be instructed to manually do so via print statements). These are memory-mapped files necessary for cross validation. For <code>cv_iht</code>, <strong>you must have <code>x</code> GB of free space and RAM on your hard disk</strong> where <code>x</code> is your <code>.bed</code> file size. For <code>cv_iht_distribute_fold</code>, you must have enough RAM and disk space to fit all <code>q</code> training datasets simultaneously, each of which typically requires <code>(q - 1)/q * x</code> GB. </p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.L0_reg" href="#MendelIHT.L0_reg"><code>MendelIHT.L0_reg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">L0_reg(x, xbm, z, y, J, k, d, l)</code></pre><p>Runs Iterative Hard Thresholding for GWAS data <code>x</code>, response <code>y</code>, and non-genetic covariates <code>z</code> on a specific sparsity parameter <code>k</code>. </p><p>One needs to construct a SnpBitMatrix type (<code>xbm</code>) before running this function.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra</li><li><code>xbm</code>: The bitarray representation of <code>x</code>. This matrix is loaded in RAM and performs linear algebra. It&#39;s possible to set scale=false for xbm, especially when rare SNPs exist</li><li><code>z</code>: Matrix of non-genetic covariates. The first column usually denotes the intercept. </li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups (set as 1 if no group infomation available)</li><li><code>k</code>: Number of non-zero predictors in each group</li><li><code>d</code>: A distribution (e.g. Normal, Poisson)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>group</code> vector storing group membership</li><li><code>weight</code> vector storing vector of weights containing prior knowledge on each SNP</li><li><code>use_maf</code> indicates whether we want to scale the projection with minor allele frequencies (see paper)</li><li><code>debias</code> is boolean indicating whether we debias at each iteration (see paper)</li><li><code>verbose</code> boolean indicating whether we want to print results if model does not converge. Should set to false for multithread/multicore computing</li><li><code>init</code> boolean indicating whether we want to initialize β to sensible values through fitting. This is not efficient yet. </li><li><code>tol</code> is used to track convergence</li><li><code>max_iter</code> is the maximum IHT iteration for a model to converge. Defaults to 200, or 100 for cross validation</li><li><code>max_step</code> is the maximum number of backtracking. Since l0 norm is not convex, we have no ascent guarantee</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/iht.jl#L1-L29">source</a><div><div><pre><code class="language-none">L0_reg(x, z, y, J, k, d, l)</code></pre><p>IHT algorithm that works on general matrices. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A general matrix. User should standardize it first. </li><li><code>z</code>: Other covariates. The column of intercept should go here.</li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups (set as 1 if no group infomation available)</li><li><code>k</code>: Number of non-zero predictors in each group</li><li><code>d</code>: A distribution (e.g. Normal, Poisson)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li></ul><p><strong>Optional Arguments</strong></p><p>Optional arguments are the same as the <code>L0_reg</code> that works on SnpArrays.</p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/iht.jl#L122-L138">source</a><div><div><pre><code class="language-none">Estimates the nuisance parameter in addition to estimating the mean using IHT.</code></pre><p>We alternate between estimating the mean using IHT and estimating the nuisance parameter using maximum loglikelihood. Currently, only negative binomial regression supports estimating  nuisance paramter, and the method of choice includes Newton or MM. This can be specified with <code>est_r = :MM</code> or <code>est_r = :Newton</code>.</p><p>Note: Convergence criteria does not track the <code>r</code> paramter. </p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/negbinfit_nuisance.jl#L1-L10">source</a><div><div><pre><code class="language-none">L0_reg(x, z, y, J, k, d, l)</code></pre><p>IHT algorithm that works on general matrices. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A general matrix. User should standardize it first. </li><li><code>z</code>: Other covariates. The column of intercept should go here.</li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups (set as 1 if no group infomation available)</li><li><code>k</code>: Number of non-zero predictors in each group</li><li><code>d</code>: A distribution (e.g. Normal, Poisson)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li></ul><p><strong>Optional Arguments</strong></p><p>Optional arguments are the same as the <code>L0_reg</code> that works on SnpArrays.</p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/negbinfit_nuisance.jl#L105-L121">source</a></section><h2><a class="nav-anchor" id="Supported-GLM-models-and-Link-functions-1" href="#Supported-GLM-models-and-Link-functions-1">Supported GLM models and Link functions</a></h2><p>MendelIHT borrows distribution and link functions implementationed in <a href="http://juliastats.github.io/GLM.jl/stable/">GLM.jl</a> and <a href="https://juliastats.github.io/Distributions.jl/stable/">Distributions.jl</a></p><p>Distributions (listed with their canonical link) that work with <code>L0_reg</code> and <code>cv_iht</code> are:</p><pre><code class="language-none">          Normal (IdentityLink)
       Bernoulli (LogitLink)
         Poisson (LogLink)
NegativeBinomial (LogLink)
           Gamma (InverseLink) **(not tested)**
 InverseGaussian (InverseSquareLink) **(not tested)**</code></pre><p>Examples of these distributions in their default value (code from <a href="https://github.com/JuliaStats/GLM.jl/issues/289">this post</a>):</p><pre><code class="language-julia">using Distributions, PyPlot
figure(figsize=(6,5))
dfxs = [Bernoulli(),Gamma(),InverseGaussian(),NegativeBinomial(),Normal(),Poisson()]
dnames = [&quot;Bernoulli&quot;,&quot;Gamma&quot;,&quot;InverseGaussian&quot;,&quot;NegativeBinomial&quot;,&quot;Normal&quot;,&quot;Poisson&quot;]
for i in 1:length(dfxs)
    subplot(7,1,i); subplots_adjust(hspace=0)
    PyPlot.plt.hist(rand(dfxs[i], 100000),-7.5:0.1:7.5,align=&quot;left&quot;,label=&quot;x&quot;);xticks(-8:8)
    ax= gca()
    ax.yaxis.set_visible(false);ax.spines[&quot;left&quot;].set_visible(false);ax.spines[&quot;right&quot;].set_visible(false);ax.spines[&quot;top&quot;].set_visible(false)
    i !== length(dfxs) &amp;&amp; ax.xaxis.set_visible(false);annotate(dnames[i],xy=[0,0.5],xycoords=&quot;axes fraction&quot;,ha=&quot;right&quot;,va=&quot;center&quot;)
end</code></pre><p><img src="../output_6_0.png" alt="png"/></p><p>Available link functions are:</p><pre><code class="language-none">CauchitLink
CloglogLink
IdentityLink
InverseLink
InverseSquareLink
LogitLink
LogLink
ProbitLink
SqrtLink</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>For logistic regression, the <code>ProbitLink</code> seems to work better than <code>LogitLink</code>. For <code>d = NegativeBinomial</code> or <code>d=Gamma</code>, the link function must be <code>LogLink</code>. </p></div></div><h2><a class="nav-anchor" id="Specifying-Groups-and-Weights-1" href="#Specifying-Groups-and-Weights-1">Specifying Groups and Weights</a></h2><p>When you have group and weight information, you input them as optional arguments in <code>L0_reg</code> and <code>cv_iht</code>. The weight vector is a vector of Float64, while the group vector is a vector of integers. For instance,</p><pre><code class="language-Julia">    g = #import group vector
    w = #import weight vector
    J = length(unique(g)) # specify number of non-zero groups
    result = L0_reg(x, xbm, z, y, J, k, d(), l, group=g, weight=w)</code></pre><h2><a class="nav-anchor" id="Simulation-Utilities-1" href="#Simulation-Utilities-1">Simulation Utilities</a></h2><p>MendelIHT provides some simulation utilities that help users explore the function and capabilities of iterative hard thresholding. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.simulate_random_snparray" href="#MendelIHT.simulate_random_snparray"><code>MendelIHT.simulate_random_snparray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate_random_snparray(n::Integer, p::Integer, s::String; mafs::Vector{Float64}, min_ma::Integer)</code></pre><p>Creates a random SnpArray in the current directory without missing value,  where each SNP has ⫺5 (default) minor alleles. </p><p>Note: if supplied minor allele frequency is extremely small, it could take a long time for  the simulation to generate samples where at least <code>min_ma</code> (defaults to 5) are present. </p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of samples</li><li><code>p</code>: number of SNPs</li><li><code>s</code>: name of SnpArray that will be created (memory mapped) in the current directory. To not memory map, use <code>undef</code>.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>mafs</code>: vector of desired minor allele freuqencies (uniform(0, 0.5) by default)</li><li><code>min_ma</code>: the minimum number of minor alleles that must be present for each SNP (defaults to 5)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/simulate_utilities.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.simulate_correlated_snparray" href="#MendelIHT.simulate_correlated_snparray"><code>MendelIHT.simulate_correlated_snparray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate_correlated_snparray(n, p, s; block_length, hap, prob)</code></pre><p>Simulates a SnpArray with correlation. SNPs are divided into blocks where each adjacent SNP is the same with probability prob. There are no correlation between blocks.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of samples</li><li><code>p</code>: number of SNPs</li><li><code>s</code>: name of SnpArray that will be created (memory mapped) in the current directory. To not memory map, use <code>undef</code>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>block_length</code>: length of each LD block</li><li><code>hap</code>: number of haplotypes to simulate for each block</li><li><code>prob</code>: with probability <code>prob</code> an adjacent SNP would be the same. </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/simulate_utilities.jl#L99-L114">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Simulating a SnpArray with <span>$n$</span> subjects and <span>$p$</span> SNPs requires up to <span>$4np$</span> bits of RAM. Make sure you have enough RAM before simulating very large SnpArrays.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.simulate_random_response" href="#MendelIHT.simulate_random_response"><code>MendelIHT.simulate_random_response</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate_random_response(x::SnpArray, xbm::SnpBitMatrix, k::Int, d::UnionAll, l::Link)</code></pre><p>This function simulates a random response (trait) vector <code>y</code> based on provided x, β, distirbution, and link function. When the distribution is from Poisson, Gamma, or Negative Binomial, we simulate <code>β ∼ N(0, 0.3)</code>  to roughly ensure the mean of response <code>y</code> doesn&#39;t become too large. For other distributions, we choose <code>β ∼ N(0, 1)</code>. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The SnpArray</li><li><code>xbm</code>: SnpBitMatrix type of your SnpArray</li><li><code>k</code>: the true number of predictors. </li><li><code>d</code>: The distribution of the simulated trait (note <code>typeof(d) = UnionAll</code> but <code>typeof(d())</code> is an actual distribution: e.g. Normal)</li><li><code>l</code>: The link function. Input <code>canonicallink(d())</code> if you want to use the canonical link of <code>d</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>r</code>: The number of success until stopping in negative binomial regression, defaults to 10</li><li><code>α</code>: Shape parameter of the gamma distribution, defaults to 1</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/simulate_utilities.jl#L184-L202">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For negative binomial and gamma, the link function must be LogLink. For Bernoulli, the probit link seems to work better than logitlink when used in <code>cv_iht</code> or <code>L0_reg</code>. </p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>adhoc_add_correlation</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.make_bim_fam_files" href="#MendelIHT.make_bim_fam_files"><code>MendelIHT.make_bim_fam_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_bim_fam_files(x::SnpArray, y, name::String)</code></pre><p>Creates .bim and .bed files from a SnpArray. </p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: A SnpArray (i.e. <code>.bed</code> file on the disk) for which you wish to create corresponding <code>.bim</code> and <code>.fam</code> files.</li><li><code>name</code>: string that should match the <code>.bed</code> file (Do not include <code>.bim</code> or <code>.fam</code> extensions in <code>name</code>).</li><li><code>y</code>: Trait vector that will go in to the 6th column of <code>.fam</code> file. </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/simulate_utilities.jl#L263-L272">source</a></section><h2><a class="nav-anchor" id="Other-Useful-Functions-1" href="#Other-Useful-Functions-1">Other Useful Functions</a></h2><p>MendelIHT additionally provides useful utilities that may be of interest to a few advanced users. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.iht_run_many_models" href="#MendelIHT.iht_run_many_models"><code>MendelIHT.iht_run_many_models</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Runs IHT across many different model sizes specifed in <code>path</code>.  This is basically the same as <code>cv_iht</code> except we <strong>DO NOT</strong> validate each model  in a holdout set, meaning that this will definitely induce overfitting as we increase model size. Use this to perform a quick estimate a range of feasible model sizes before  engaging in full cross validation. </p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/cross_validation.jl#L131-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.loglikelihood" href="#MendelIHT.loglikelihood"><code>MendelIHT.loglikelihood</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loglikelihood(d::UnivariateDistribution, y::AbstractVector, μ::AbstractVector)</code></pre><p>Calculates the loglikelihood of observing <code>y</code> given mean <code>μ</code> and some distribution  <code>d</code>. </p><p>Note that loglikelihood is the sum of the logpdfs for each observation.  For each logpdf from Normal, Gamma, and InverseGaussian, we scale by dispersion. </p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/utilities.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.project_k!" href="#MendelIHT.project_k!"><code>MendelIHT.project_k!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">project_k!(x::AbstractVector, k::Integer)</code></pre><p>Sets all but the largest <code>k</code> entries of <code>x</code> to 0. </p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">using MendelIHT
x = [1.0; 2.0; 3.0]
project_k!(x, 2) # keep 2 largest entry
julia&gt; x
3-element Array{Float64,1}:
 0.0
 2.0
 3.0</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x</code>: the vector to project.</li><li><code>k</code>: the number of components of <code>x</code> to preserve.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/utilities.jl#L389-L409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.project_group_sparse!" href="#MendelIHT.project_group_sparse!"><code>MendelIHT.project_group_sparse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">project_group_sparse!(y::AbstractVector, group::AbstractVector, J::Integer, k&lt;:Real)</code></pre><p>When <code>k</code> is an integer, projects the vector <code>y</code> onto the set with at most <code>J</code> active groups  and at most <code>k</code> active predictors per group. When 0 &lt; k &lt; 1, <code>k</code> is treated as a percentage and top groups will preserve <code>k</code> percent of top predictors. Assumes there are no unknown or  overlaping group membership.</p><p>Note: In the <code>group</code> vector, the first group must be 1, and the second group must be 2...etc. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">using MendelIHT
J, k, n = 2, 3, 20
y = collect(1.0:20.0)
y_copy = copy(y)
group = rand(1:5, n)
project_group_sparse!(y, group, J, k)
for i = 1:length(y)
    println(i,&quot;  &quot;,group[i],&quot;  &quot;,y[i],&quot;  &quot;,y_copy[i])
end

J, k, n = 2, 0.9, 20
y = collect(1.0:20.0)
y_copy = copy(y)
group = rand(1:5, n)
project_group_sparse!(y, group, J, k)
for i = 1:length(y)
    println(i,&quot;  &quot;,group[i],&quot;  &quot;,y[i],&quot;  &quot;,y_copy[i])
end</code></pre><p><strong>Arguments</strong></p><ul><li><code>y</code>: The vector to project</li><li><code>group</code>: Vector encoding group membership</li><li><code>J</code>: Max number of non-zero group</li><li><code>k</code>: Positive integer or number ∈ (0, 1). </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/utilities.jl#L417-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.maf_weights" href="#MendelIHT.maf_weights"><code>MendelIHT.maf_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">maf_weights(x::SnpArray; max_weight::T = Inf)</code></pre><p>Calculates the prior weight based on minor allele frequencies. </p><p>Returns an array of weights where <code>w[i] = 1 / (2 * sqrt(p[i] (1 - p[i]))) ∈ (1, ∞).</code> Here <code>p</code> is the minor allele frequency computed by <code>maf()</code> in SnpArrays. </p><ul><li><code>x</code>: A SnpArray </li><li><code>max_weight</code>: Maximum weight for any predictor. Defaults to <code>Inf</code>. </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/utilities.jl#L534-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.naive_impute" href="#MendelIHT.naive_impute"><code>MendelIHT.naive_impute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">naive_impute(x, destination)</code></pre><p>Imputes missing entries of a SnpArray using the mode of each SNP, and saves the result in a new file called destination in current directory.  Non-missing entries are the same. </p></div></div><a class="source-link" target="_blank" href="https://github.com/OpenMendel/MendelIHT.jl/blob/c7411bae73c83a3b5553aa4929c386564f2fa43c/src/utilities.jl#L670-L676">source</a></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
