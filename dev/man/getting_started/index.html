<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · MendelIHT</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MendelIHT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>Getting Started</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Step-Workflow-1">3 Step Workflow</a></li><li><a class="toctext" href="#Core-Functions-1">Core Functions</a></li><li><a class="toctext" href="#Supported-GLM-models-and-Link-functions-1">Supported GLM models and Link functions</a></li><li><a class="toctext" href="#Specifying-Groups-and-Weights-1">Specifying Groups and Weights</a></li><li><a class="toctext" href="#Simulation-Utilities-1">Simulation Utilities</a></li><li><a class="toctext" href="#Other-Useful-Functions-1">Other Useful Functions</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Getting Started</a></li></ul><a class="edit-page" href="https://github.com/biona001/MendelIHT.jl/blob/master/docs/src/man/getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>In this section, we outline the basic procedure to analyze your GWAS data with MendelIHT. </p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Press <code>]</code> to enter package manager mode and type the following (after <code>pkg&gt;</code>):</p><pre><code class="language-none">(v1.0) pkg&gt; add https://github.com/OpenMendel/SnpArrays.jl
(v1.0) pkg&gt; add https://github.com/biona001/MendelIHT.jl</code></pre><p>The order of installation is important!</p><h2><a class="nav-anchor" id="Step-Workflow-1" href="#Step-Workflow-1">3 Step Workflow</a></h2><p>Most analysis consists of 3 simple steps:</p><ol><li>Import data.</li><li>Run <code>cv_iht</code> to determine best model size.</li><li>Run <code>L0_reg</code> to obtain final model.</li></ol><p>We believe the best way to learn is through examples. Head over to the example section on the left to see these steps in action. Nevertheless, below contains function signatures and use cautions that any users should be aware. </p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>(1) <code>MendelIHT</code> assumes there are <strong>NO missing genotypes</strong>, and (2) the trios (<code>.bim</code>, <code>.bed</code>, <code>.fam</code>) must all be present in the same directory. </p></div></div><h2><a class="nav-anchor" id="Core-Functions-1" href="#Core-Functions-1">Core Functions</a></h2><p>A standard analysis runs only 2 functions, other than importing data.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.cv_iht" href="#MendelIHT.cv_iht"><code>MendelIHT.cv_iht</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cv_iht(d, l, x, z, y, J, path, num_fold)</code></pre><p>Performs q-fold cross validation and returns the deviance residuals for each model. </p><p>Each CPU runs a different model for a given fold. To use this function, start julia  using 4 (the more the better) processors by:</p><pre><code class="language-none">julia&gt; using Distributed
julia&gt; addprocs(4)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: A distribution (e.g. Normal, Bernoulli)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li><li><code>x</code>: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra</li><li><code>z</code>: Matrix of non-genetic covariates. The first column usually denotes the intercept. </li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups</li><li><code>path</code>: Vector storing different model sizes</li><li><code>num_fold</code>: Number of cross validation folds. For large data do not set this to be greater than 5</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>group</code> vector storing group membership</li><li><code>weight</code> vector storing vector of weights containing prior knowledge on each SNP</li><li><code>folds</code>: Vector that separates the sample into q disjoint subsets</li><li><code>init</code>: Boolean indicating whether we should initialize IHT algorithm at a good starting guess</li><li><code>use_maf</code>: Boolean indicating we should scale the projection step by a weight vector </li><li><code>debias</code>: Boolean indicating whether we should debias at each IHT step</li><li><code>showinfo</code>: Whether we want IHT to print meaningful intermediate steps</li><li><code>parallel</code>: Whether we want to run cv_iht using multiple CPUs (highly recommended)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/cross_validation.jl#L1-L31">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Do not</strong> delete intermediate files (e.g. <code>train.bed</code>) created by <code>cv_iht</code>. These are memory-mapped files necessary for cross validation. In order to successfully create these files, <strong>you must have <code>x</code> GB of free space on your hard disk</strong> where <code>x</code> is your <code>.bed</code> file size.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.L0_reg" href="#MendelIHT.L0_reg"><code>MendelIHT.L0_reg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">L0_reg(x, xbm, z, y, J, k, d, l)</code></pre><p>Runs Iterative Hard Thresholding for GWAS data <code>x</code>, response <code>y</code>, and non-genetic covariates <code>z</code> on a specific sparsity parameter <code>k</code>. </p><p>One needs to construct a SnpBitMatrix type (xbm below) before running this function.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra</li><li><code>xbm</code>: The bitarray representation of <code>x</code>. This matrix is loaded in RAM and performs linear algebra. It&#39;s possible to set scale=false for xbm, especially when rare SNPs exist</li><li><code>z</code>: Matrix of non-genetic covariates. The first column usually denotes the intercept. </li><li><code>y</code>: Response vector</li><li><code>J</code>: The number of maximum groups</li><li><code>k</code>: Number of non-zero predictors in each group</li><li><code>d</code>: A distribution (e.g. Normal, Poisson)</li><li><code>l</code>: A link function (e.g. Loglink, ProbitLink)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>group</code> vector storing group membership</li><li><code>weight</code> vector storing vector of weights containing prior knowledge on each SNP</li><li><code>use_maf</code> indicates whether we want to scale the projection with minor allele frequencies (see paper)</li><li><code>debias</code> is boolean indicating whether we debias at each iteration (see paper)</li><li><code>show_info</code> boolean indicating whether we want to print results if model does not converge. Should set to false for multithread/multicore computing</li><li><code>init</code> boolean indicating whether we want to initialize β to sensible values through fitting. This is not efficient yet. </li><li><code>tol</code> is used to track convergence</li><li><code>max_iter</code> is the maximum IHT iteration for a model to converge. Defaults to 200, or 100 for cross validation</li><li><code>max_step</code> is the maximum number of backtracking. Since l0 norm is not convex, we have no ascent guarantee</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/iht.jl#L1-L29">source</a></section><h2><a class="nav-anchor" id="Supported-GLM-models-and-Link-functions-1" href="#Supported-GLM-models-and-Link-functions-1">Supported GLM models and Link functions</a></h2><p>MendelIHT borrows distribution and link functions implementationed in <a href="http://juliastats.github.io/GLM.jl/stable/">GLM.jl</a> and <a href="https://juliastats.github.io/Distributions.jl/stable/">Distributions.jl</a></p><p>Distributions (listed with their canonical link) that work with <code>L0_reg</code> and <code>cv_iht</code> are:</p><pre><code class="language-none">          Normal (IdentityLink)
       Bernoulli (LogitLink)
         Poisson (LogLink)
NegativeBinomial (LogLink)
           Gamma (InverseLink) **(not tested)**
 InverseGaussian (InverseSquareLink) **(not tested)**</code></pre><p>Available link functions are:</p><pre><code class="language-none">CauchitLink
CloglogLink
IdentityLink
InverseLink
InverseSquareLink
LogitLink
LogLink
ProbitLink
SqrtLink</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>For logistic regression, the <code>ProbitLink</code> seems to work better than <code>LogitLink</code>. For <code>d = NegativeBinomial</code> or <code>d=Gamma</code>, the link function must be <code>LogLink</code>. </p></div></div><h2><a class="nav-anchor" id="Specifying-Groups-and-Weights-1" href="#Specifying-Groups-and-Weights-1">Specifying Groups and Weights</a></h2><p>When you have group and weight information, you input them as optional arguments in <code>L0_reg</code> and <code>cv_iht</code>. The weight vector is a vector of Float64, while the group vector is a vector of integers. For instance,</p><pre><code class="language-Julia">    g = #import group vector
    w = #import weight vector
    result = L0_reg(x, xbm, z, y, 1, k, d(), l, group=g, weight=w)</code></pre><h2><a class="nav-anchor" id="Simulation-Utilities-1" href="#Simulation-Utilities-1">Simulation Utilities</a></h2><p>MendelIHT provides some simulation utilities that help users explore the function and capabilities of iterative hard thresholding. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.simulate_random_snparray" href="#MendelIHT.simulate_random_snparray"><code>MendelIHT.simulate_random_snparray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate_random_snparray(n::Integer, p::Integer, s::String; mafs::Vector{Float64}, min_ma::Integer)</code></pre><p>Creates a random SnpArray in the current directory without missing value,  where each SNP has ⫺5 (default) minor alleles. </p><p>Note: if supplied minor allele frequency is extremely small, it could take a long time for  the simulation to generate samples where at least <code>min_ma</code> (defaults to 5) are present. </p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: number of samples</li><li><code>p</code>: number of SNPs</li><li><code>s</code>: name of the simulated SnpArray that will be created on the current directory</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>mafs</code>: vector of desired minor allele freuqencies</li><li><code>min_ma</code>: the minimum number of minor alleles that must be present for each SNP (defaults to 5)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/simulate_utilities.jl#L1-L18">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Simulating a SnpArray with <span>$n$</span> subjects and <span>$p$</span> SNPs requires roughly <span>$n \times p \times 4$</span> bits of RAM. Make sure you have enough RAM before simulating very large SnpArrays.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.simulate_random_response" href="#MendelIHT.simulate_random_response"><code>MendelIHT.simulate_random_response</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate_random_response(x::SnpArray, xbm::SnpBitMatrix, k::Int, d::UnionAll, l::Link)</code></pre><p>This function simulates a random response (trait) vector <code>y</code> based on provided x, β, distirbution, and link function. </p><p>When the distribution is from Poisson, Gamma, or Negative Binomial, we simulate <code>β ∼ N(0, 0.3)</code>  to roughly ensure the mean of response <code>y</code> doesn&#39;t become too large. For other distributions, we choose <code>β ∼ N(0, 1)</code>. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The SnpArray</li><li><code>xbm</code>: SnpBitMatrix type of your SnpArray</li><li><code>k</code>: the true number of predictors. </li><li><code>d</code>: The distribution of the simulated trait (note <code>typeof(d) = UnionAll</code> but <code>typeof(d())</code> is an actual distribution: e.g. Normal)</li><li><code>l</code>: The link function. Input <code>canonicallink(d())</code> if you want to use the canonical link of <code>d</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>nn</code>: The number of success until stopping in negative binomial regression, defaults to 10</li><li><code>α</code>: Shape parameter of the gamma distribution, defaults to 1</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/simulate_utilities.jl#L97-L117">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For negative binomial and gamma, the link function must be LogLink. For Bernoulli, the probit link seems to work better than logitlink when used in <code>cv_iht</code> or <code>L0_reg</code>. </p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.adhoc_add_correlation" href="#MendelIHT.adhoc_add_correlation"><code>MendelIHT.adhoc_add_correlation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adhoc_add_correlation(x::SnpArray, ρ::Float64, pos::Int64, location::Vector{Int})</code></pre><p>Makes 1 SNP (a column of <code>x</code>) correlate with SNPs in <code>location</code> with correlation coefficient roughly <code>ρ</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: the snparray</li><li><code>ρ</code>: correlation coefficient</li><li><code>pos</code>: the position of the target SNP that everything would be correlated to</li><li><code>location</code>: All the SNPs that shall be correlated with the SNP at position <code>pos</code> with correlation <code>ρ</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/simulate_utilities.jl#L154-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.make_bim_fam_files" href="#MendelIHT.make_bim_fam_files"><code>MendelIHT.make_bim_fam_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_bim_fam_files(x::SnpArray, y, name::String)</code></pre><p>Creates .bim and .bed files from a SnpArray. </p><p><strong>Arguments:</strong></p><p><code>x</code>: A SnpArray (i.e. <code>.bed</code> file on the disk) for which you wish to create corresponding <code>.bim</code> and <code>.fam</code> files. <code>name</code>: string that should match the <code>.bed</code> file (Do not include <code>.bim</code> or <code>.fam</code> extensions in <code>name</code>). <code>y</code>: Trait vector that will go in to the 6th column of <code>.fam</code> file. </p></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/simulate_utilities.jl#L188-L197">source</a></section><h2><a class="nav-anchor" id="Other-Useful-Functions-1" href="#Other-Useful-Functions-1">Other Useful Functions</a></h2><p>MendelIHT additionally provides useful utilities that may be of interest to a few advanced users. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.iht_run_many_models" href="#MendelIHT.iht_run_many_models"><code>MendelIHT.iht_run_many_models</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Runs IHT across many different model sizes specifed in <code>path</code>. </p><p>This is basically the same as <code>cv_iht</code> except we <strong>DO NOT</strong> validate each model  in a holdout set, meaning that this will definitely induce overfitting as we increase model size. Use this to perform a quick estimate a range of feasible model sizes before  engaging in full cross validation. </p></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/cross_validation.jl#L74-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.loglikelihood" href="#MendelIHT.loglikelihood"><code>MendelIHT.loglikelihood</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loglikelihood(y::AbstractVector, xb::AbstractVector, d::UnivariateDistribution)</code></pre><p>This function calculates the loglikelihood of observing <code>y</code> given <code>μ</code> = g^{-1}(xb) and some distribution <code>d</code> from the exp family. Note that loglikelihood is the sum  of the logpdfs for each observation. For each logpdf, we </p></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/utilities.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.project_k!" href="#MendelIHT.project_k!"><code>MendelIHT.project_k!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">project_k!(x::AbstractVector, k::Integer)</code></pre><p>This function projects a vector <code>x</code> onto the set S<em>k = { y in R^p : || y ||</em>0 &lt;= k }.</p><p>Arguments:</p><ul><li><code>b</code> is the vector to project.</li><li><code>k</code> is the number of components of <code>b</code> to preserve.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/utilities.jl#L267-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.project_group_sparse!" href="#MendelIHT.project_group_sparse!"><code>MendelIHT.project_group_sparse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">project_group_sparse!(y::AbstractVector, group::AbstractVector, J::Integer, k::Integer)</code></pre><p>Projects the vector y onto the set with at most J active groups and at most k active predictors per group. The variable group encodes group membership. Currently assumes there are no unknown or overlaping group membership.</p></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/utilities.jl#L283-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MendelIHT.maf_weights" href="#MendelIHT.maf_weights"><code>MendelIHT.maf_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">maf_weights(x::SnpArray; max_weight::T = Inf)</code></pre><p>Calculates the prior weight based on minor allele frequencies. </p><p>Returns an array of weights where      <code>w[i] = 1 / (2 * sqrt(p[i] (1 - p[i]))) ∈ (1, ∞)</code> here <code>p</code> is the minor allele frequency computed by <code>maf()</code> in SnpArrays. </p></div></div><a class="source-link" target="_blank" href="https://github.com/biona001/MendelIHT.jl/blob/206d1c21a8cef8a0bbc332f842f3a1a725f83b54/src/utilities.jl#L324-L332">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>initialize_beta!</code>. Check Documenter&#39;s build log for details.</p></div></div><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
